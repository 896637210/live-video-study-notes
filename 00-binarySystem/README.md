## 二进制系统

常见的进制系统有二进制、八进制、十进制、十六进制，概念大家都懂而重点在于进制间的转换和运算，实际上转换和运算都是通过计算机完成，所以建议是理解并可以手写转换和运算然后通过计算机验证，其中在`JS`里验证的方法很简单。

`toString`方法用于进制间的转换，但要记住结果返回的是字符串：

```js
// 把数字转换成你想要的进制表示，例如把十进制的100转换为十六进制
(100).toString(16) === "64";
// 反过来，把十六进制的0x64转换为十进制
(0x64).toString(10) === "100";
```

`parseInt`方法用于解析某个字符串或数字到十进制，前提是你已经知道目标的进制是多少，但要记住结果返回的是数字：

```js
// 默认以十进制读取目标：
parseInt(64) === 64;

// 除非你标识目标的进制类型，例如：
parseInt(64, 16) === 100;
parseInt(0x64) === 100;
parseInt("0x64") === 100;
```

### 其他进制转十进制

技巧就是通过基数把进制进行分解，用 JS 语法来分解，其中`**`为幂符号，并且`0`的幂都是`1`;

二进制的`101010`，基数为`2`，可以分解为：

```js
1 * 2 ** 5 === 32;
0 * 2 ** 4 === 0;
1 * 2 ** 3 === 8;
0 * 2 ** 2 === 0;
1 * 2 ** 1 === 2;
0 * 2 ** 0 === 0;

32 + 0 + 8 + 0 + 2 + 0 = 42;
```

八进制的`33`，基数为`8`，可以分解为：

```js
3 * 8 ** 1 === 24;
3 * 8 ** 0 === 3;

24 + 3 === 27;
```

十六进制的`1B`，基数为`16`，可以分解为：

```js
01 * 16 ** 1 === 16;
11 * 16 ** 0 === 11;

16 + 11 === 27;
```

### 十进制转二进制

这个会难一些而且方法有很多，其中最容易的一个方法是重复除以`2`并记录余数，一直到`0`为止，例如十进制的`245`：

| 取整 | 取余 |
| ---- | ---- |
| 122  | 1    |
| 61   | 0    |
| 30   | 1    |
| 15   | 0    |
| 7    | 1    |
| 3    | 1    |
| 1    | 1    |
| 0    | 1    |

再从下往上组合就得二进制的结果`11110101`，理解原理后通过简单的`JS`递归也可以转换：

```js
function decimalToBinary(num, result = []) {
  const round = Math.floor(num / 2);
  result.unshift(num % 2);
  if (round === 0) {
    return result.join("");
  } else {
    return decimalToBinary(round, result);
  }
}

decimalToBinary(245) === "11110101";

// 验算一下
(245).toString(2) === "11110101";
```

### 十六进制和二进制互转

从二进制转换为十六进制和十六进制转换为二进制实际上非常容易，这是因为十六进制是`16`的基数，实际上是`2`的`4`次幂，只要把逐个字符看成十进制(其中`A=10`、`B=11`类推)，再转为`4`个字符的二进制，再组合即可。

例如十六进制的`75C`转为二进制：

```js
7 === 0b0111;
5 === 0b0101;
12 === 0b1100;

0x75c === 0b011101011100;
```

反过来二进制的`011101011100`转为十六进制：

```js
0b0111 === 7;
0b0101 === 5;
0b1100 === 12;

0b011101011100 === 0x75c;
```

### 八进制和二进制互转

这个和上面一样道理，只要把逐个字符看成十进制，再转为`3`个字符的二进制，再组合即可，不再累述。

### 二进制负数

二进制负数的表示会相对复杂，其中它有两种表示方法，先说第一种就是用最左边的一个符号表示正负。例如我们在八位的二进制里，可以约定最左边的一位：`0`表示数字为正数，`1`表示数字为负数。

根据约定，就有一下结果：

```js
1000011 === -3;
0000011 === 3;
```

想一下，假如没有这个正负标记的时候，八位二进制的表示范围为：

```js
// 最小值为0，最大值为255，总共有256个可能的数字
00000000 === 0;
11111111 === 255;
```

有了正负标记之后，八位二进制的表示范围为：

```js
// 最小值为-127，最大值为127，总共有255个可能的数字
11111111 === -127;
10000000 === 0;
00000000 === 0;
01111111 === 127;
```

那么问题就来了，使用这种表示法，那就要指定我们的数值是多少位，上面是`8`位，也有`16`位和`32`位的情况，假如使用的是`32`位的时候，我想表示一个值为`-1`时，就必须这样写：

```js
10000000000000000000000000000001 === -1;
```

这种表示方法很累赘，那么能不能把正负标记放在最右边呢，那就不会造成存在上面这种现象，答案是可以但没必要，那样不单会造成人读时理解的困难，计算机所需的处理也会增加。

第二种就是用补码去表示负数，简单概况就是负数的二进制表示法为，取其正数，再取其反码，再加一即可。

例如用八位二进制表示`-5`时：

```js
// 首先取正数
5;

// 再转换为二进制
101;

// 再填充到所需的位数
00000101;

// 再反转数字
11111010;

// 最后加1，完成
11111011;
```

问题是为什么要这样做，网上有很多解释，这篇说的很好：[补码原理——负数为什么要用补码表示](https://blog.csdn.net/leonliu06/article/details/78685197)

那么问题又来了，这个二进制的`11111011`，我怎么知道你是正数的`251`还是负数的`-5`呢？那就要看计算机中是以有符号进行存储还是无符号进行存储，如果是无符号存储，则其为一个正数`251`，若是有符号存储，再看最左边的一位是不是`1`，是`1`的话则为补码存储也就是负数的`-5`。

假如我知道`11111011`是有符号存储的，那我就反过来求十进制的负数吧：

```js
// 首先减一
11111010;

// 再反转数字
00000101;

// 换十进制
5;

// 取负数，完成
-5;
```

再回头看，假如使用的是`32`位的时候，我想表示一个值为`-1`时，使用补码写法：

```js
// 首先取正数
1;

// 再转换为二进制
1;

// 再填充到所需的位数
000000000000000000000001;

// 再反转数字
111111111111111111111110;

// 最后加1，完成
111111111111111111111111;
```

假如你不知道有没符号的情况下就去取值，可能会表示出一个偏差相当大的一个数，所以要特别注意。

在`JS`里值得注意的一个是`toString`不会按上面预期的返回补码表示法：

```js
(-5).toString(2) === "-101";
```

对比一下上面的转换步骤，会发现`JS`把取反码和加一这两个步骤用一个负号取代替了。

### 二进制分数

大家都知道分数可以用小数表示，例如`1/2`就是精确值`0.5`，但`1/3`只能采用近似值如`0.3333333`表示，实际上二进制也存在这种情况，用二进制也只能近似的表示`1/3`，常见于在`JS`里为什么`0.1 + 0.2`不等于`0.3`。

二进制小数会表示为`101.101`，但计算机只认识`0`和`1`，小数点是不占位的，而且小数点的位置都是通过约定来定位的，在计算机里只会保存为`101101`，不知道小数点在哪里就会造成数据偏差，这种叫定点数。

看`5.265`怎么转换成二进制，整数部分单独处理，小数部分重复乘以`2`，结果小于`1`记录`0`，结果大于`1`，舍弃整数部分并记录`1`，结果等于`1`就说明分数是可以被除尽，最后用上至下组合记录值就是小数部分。

整数部分:

```js
5 === 0b101;
```

小数部分(精确到后八位)：

| 小数部分 | 记录 |
| -------- | ---- |
| 0.53     | 0    |
| 0.06     | 1    |
| 0.12     | 0    |
| 0.24     | 0    |
| 0.48     | 0    |
| 0.96     | 0    |
| 0.92     | 1    |
| 0.84     | 1    |

结果就是：

```js
101.01000011;
```

验算：

```js
(5.265).toString(2);
```

再看怎么把二进制小数转为十进制小数，这个过程和二进制整数转十进制整数类似，需要做就是先确定小数点的位置，例如二进制的`101.101`：

```js
1 * 2 ** 2 === 4;
0 * 2 ** 1 === 0;
1 * 2 ** 0 === 1;
1 * 2 ** -1 === 0.5;
0 * 2 ** -2 === 0;
1 * 2 ** -3 === 0.125;

4 + 0 + 1 + 0.5 + 0 + 0.125 === 5.625;
```

你会发现同样是`5.625`，怎么在二进制上会有偏差，因为二进制转十进制是精确的，但反过来就有可能是近似的。

### 二进制浮点

上面说的是定点数，小数点是固定在某个位置的，还有一个表示方法叫浮点数，小数点位置可以浮动的，类似我们熟悉的科学计数法，相对复杂而且有不同的标准，其中最通用的就是`IEEE-754`标准，`JS`也是使用该标准。

回忆一下科学计数法，默认都是小数点左边保留一位整数：

- 二进制时：`10100.110 = 1.0100110 * 2 ** 4`
- 十进制时：`1230000 = 1.23 * 10 ** 6`
- 十六进制时：`123.abc = 1.23abc * 16 ** 2`

以上面的十进制为例，其中`1.23`为尾数，`10`为基数，`6`为指数，很好理解。

`IEEE-754`标准为浮点数指定了两种格式：单精度和双精度。

单精度使用`4`个字节`32`位：

- `1`位表示数字的符号，`0`表示正数，`1`表示负数。
- 指数为`8`位。
- 尾数为`23`位

双精度使用`8`个字节`64`位：

- `1`位表示数字的符号，`0`表示正数，`1`表示负数。
- 指数为`11`位。
- 尾数为`52`位

双精度具有更多位，允许表示更大和更小的数字。由于尾数也较大，精度也会提高。虽然双精度浮点数具有这些优点，但它们还需要更高的处理能力。随着`CPU`处理能力的提高和`64`位计算的发展，许多编程语言和软件都默认为双精度。下面的单精度浮点数是如何工作的，双精度工作完全相同，只需更多位。

以下面这个`IEEE-754`单精度表示法的二进制数字转换为十进制科学计数法：

```js
11011011011000101100111010110111;
```

- 符号位是二进制`1`：说明是一个负数。
- 指数位是二进制`10110110`：换成十进制是`182`，根据标准的单精度，还要减去偏差值`127`，即是`55`。
- 尾数位为二进制`11000101100111010110111`：换成十进制是`6475447`，但实际上这个二进制是小数部分，整数部分隐藏了`1`，即`1.11000101100111010110111`才是它的真实身份，真正换成十进制是`1.7719334363937378`。

组合一下就有了：

```js
-1.7719334363937378 * 2 ** 55 === -63840630110945280;

// 约等于
-6.384063 * 10 ** 16;
```

反过来怎么把一个十进制数字`85.125`转为`IEEE-754`单精度表示法：

```js
// 转换整数部分
85 = 1010101;

// 转换小数部分
0.125 = 001;

// 整数和小数组合
85.125 = 1010101.001;

// 科学计数法
1010101.001 = 1.010101001 * 2 ** 6;

// 因为是正数所以符号位是0
0

// 换算指数位，加上偏差值127即可
127 + 6 = 133；
133 = 10000101；

// 换算尾数位，移除整数位和小数点即可，并且小数后面用0补全
01010100100000000000000

// 最后组合起来

0 10000101 01010100100000000000000
```

至于更具体原理网上也有很多文章：

- [https://www.h-schmidt.net/FloatConverter/IEEE754.html](https://www.h-schmidt.net/FloatConverter/IEEE754.html)
- [https://steve.hollasch.net/cgindex/coding/ieeefloat.html](https://steve.hollasch.net/cgindex/coding/ieeefloat.html)
- [https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/)
